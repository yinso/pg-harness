// Generated by CoffeeScript 1.8.0
(function() {
  var DBI, Postgres, Promise, exec, execAsync, fs, randomPort, spawn, tmp, _, _ref;

  Promise = require('bluebird');

  _ = require('underscore');

  _ref = require('child_process'), exec = _ref.exec, spawn = _ref.spawn;

  tmp = Promise.promisifyAll(require('tmp'));

  fs = Promise.promisifyAll(require('fs.extra'));

  execAsync = Promise.promisify(exec);

  DBI = require('easydbi');

  require('easydbi-pg');

  randomPort = function() {
    var max, min;
    min = min || 15000;
    max = max || 55000;
    return Math.round((max - min) * Math.random()) + min;
  };

  Postgres = (function() {
    function Postgres(options) {
      if (options == null) {
        options = {};
      }
      if (this instanceof Postgres) {
        this.port = options.port || randomPort();
        if (options.dataPath) {
          this.dataPath = options.dataPath;
        }
        return this;
      } else {
        return new Postgres();
      }
    }

    Postgres.prototype.init = function(cb) {
      var cmd, self;
      self = this;
      if (self.dataPath) {
        cmd = "initdb -A trust -D " + self.dataPath;
        return execAsync(cmd).then(function() {
          return cb(null, self);
        })["catch"](cb);
      } else {
        return tmp.dirAsync().then(function(args) {
          self.dataPath = args[0];
          cmd = "initdb -A trust -D " + self.dataPath;
          return execAsync(cmd);
        }).then(function() {
          return cb(null, self);
        })["catch"](cb);
      }
    };

    Postgres.prototype.start = function(cb) {
      var db, env, self;
      self = this;
      env = _.extend({}, process.env, {
        PGPORT: self.port
      });
      db = self.inst = spawn('postgres', ['-D', self.dataPath], {
        env: env
      });
      db.stderr.on('data', function(chunk) {
        var data;
        data = chunk.toString();
        if (data.match(/is ready to accept connections/)) {
          return cb(null, this);
        }
      });
      return db.on('close', function(code) {
        if (code !== 0) {
          return cb({
            error: 'abnormal_exit',
            code: code
          });
        }
      });
    };

    Postgres.prototype.stop = function(cb) {
      var self;
      self = this;
      self.inst.stderr.on('data', function(chunk) {
        var data;
        data = chunk.toString();
        if (data.match(/is shut down/)) {
          return cb(null, self);
        }
      });
      return self.inst.kill('SIGINT');
    };

    Postgres.prototype.clean = function(cb) {
      var path;
      path = this.dataPath;
      return fs.rmrf(path, function(err) {
        if (err) {
          console.error(err);
          return cb(err);
        } else {
          console.log(path, 'cleaned up.');
          return cb(null);
        }
      });
    };

    Postgres.prototype.connect = function(name, cb) {
      var self;
      self = this;
      return DBI.connect(name, function(err, conn) {
        if (err) {
          return cb(err);
        } else {
          self.conn = conn;
          return cb(null, self);
        }
      });
    };

    Postgres.prototype.load = function(spec, module) {
      return DBI.load(spec, module);
    };

    Postgres.prototype.disconnect = function(cb) {
      return this.conn.disconnect(cb);
    };

    Postgres.prototype.query = function(query, args, cb) {
      return this.conn.query(query, args, cb);
    };

    Postgres.prototype.queryOne = function(query, args, cb) {
      return this.conn.queryOne(query, args, cb);
    };

    Postgres.prototype.exec = function(query, args, cb) {
      return this.conn.exec(query, args, cb);
    };

    Postgres.prototype.begin = function(cb) {
      return this.conn.begin(cb);
    };

    Postgres.prototype.commit = function(cb) {
      return this.conn.commit(cb);
    };

    Postgres.prototype.rollback = function(cb) {
      return this.conn.rollback(cb);
    };

    Postgres.prototype.execScript = function(filePath, cb) {
      return this.conn.execScript(filePath, cb);
    };

    Postgres.prototype.createDB = function(name, cb) {
      var conn, install, self;
      self = this;
      install = "__create_" + name;
      DBI.setup(install, {
        type: 'pg',
        options: {
          port: this.port,
          database: 'postgres'
        }
      });
      conn = null;
      return DBI.connectAsync(install).then(function(val) {
        conn = val;
        return conn.execAsync("create database " + name, {});
      }).then(function() {
        DBI.setup(name, {
          type: 'pg',
          options: {
            port: self.port,
            database: name
          }
        });
        return conn.disconnectAsync();
      }).then(function() {
        return cb(null, self);
      })["catch"](function(e) {
        if (conn) {
          return conn.disconnect(function(e2) {
            return cb(e);
          });
        } else {
          return cb(e);
        }
      });
    };

    return Postgres;

  })();

  Promise.promisifyAll(Postgres);

  Promise.promisifyAll(Postgres.prototype);

  module.exports = Postgres;

}).call(this);
